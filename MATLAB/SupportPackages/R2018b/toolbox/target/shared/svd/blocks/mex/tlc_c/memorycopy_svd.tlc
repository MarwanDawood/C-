%%
%% memorycopy TLC file for block Memory Copy
%%   
%%  Copyright 2006-2013 The MathWorks, Inc.
%%


%implements memorycopy_svd "C"

%% Function: JustCreatedCompiledModelRecord ==============================
%function JustCreatedCompiledModelRecord(recordName) void
	%assign fullRecordName = "::CompiledModel." + recordName
	%if !EXISTS("%<fullRecordName>")
	%assign retval = 1  %% First call
	%% Create record since it does not yet exist:
	%assign %<recordName> = 1
	%assign ::CompiledModel = ::CompiledModel + %<recordName>
	%undef %<recordName>  %% Remove from current scope
	%else
		%assign retval = 0  %% Subsequent call
	%endif
	%return retval
%endfunction %% JustCreatedCompiledModelRecord
 

%% Function: AddParamsToBlock ============================================
%function AddParamsToBlock(block) void
    %if (CompiledModel.ConfigSet.SystemTargetFile == "idelink_ert.tlc") || (CompiledModel.ConfigSet.SystemTargetFile == "idelink_grt.tlc")
        %assign subFamily = targetInfo.chipInfo.subFamily
        %if (subFamily == "645x")
        	%assign DAT_MODULE = "DAT3"
        %elseif ((subFamily == "672x") || (subFamily == "643x"))
        	%assign DAT_MODULE = ""
    	%else   
        	%assign DAT_MODULE = "DAT"	
    	%endif
    %else
        %assign subFamily = ""
        %assign DAT_MODULE = "DAT"
    %endif
    
    %assign copyFromVar = SFcnParamSettings.copyFromVar
	%assign copyFromAddressSourceVar = SFcnParamSettings.copyFromAddressSourceVar
	%assign copyFromAddressVar = SFcnParamSettings.copyFromAddressVar
	%assign copyFromSrcCodeVar = SFcnParamSettings.copyFromSrcCodeVar
	%assign dataTypeFromVar = SFcnParamSettings.dataTypeFromVar
	%assign dataDimensionFromVar = SFcnParamSettings.dataDimensionFromVar
	%assign useOffsetFromVar = SFcnParamSettings.useOffsetFromVar
	%assign offsetFromSrcVar = SFcnParamSettings.offsetFromSrcVar
	%assign offsetFromVar = SFcnParamSettings.offsetFromVar
	%assign strideFromVar = SFcnParamSettings.strideFromVar
	%assign copyToVar = SFcnParamSettings.copyToVar
	%assign copyToAddressSourceVar = SFcnParamSettings.copyToAddressSourceVar
	%assign copyToAddressVar = SFcnParamSettings.copyToAddressVar
	%assign copyToSrcCodeVar = SFcnParamSettings.copyToSrcCodeVar
	%assign dataTypeToVar = SFcnParamSettings.dataTypeToVar
	%assign useOffsetToVar = SFcnParamSettings.useOffsetToVar
	%assign offsetToSrcVar = SFcnParamSettings.offsetToSrcVar
	%assign offsetToVar = SFcnParamSettings.offsetToVar
	%assign strideToVar = SFcnParamSettings.strideToVar
	%assign useInitValueVar = SFcnParamSettings.useInitValueVar
	%assign initValueSrcVar = SFcnParamSettings.initValueSrcVar
	%assign initValueVar = SFcnParamSettings.initValueVar
	%assign initValueSrcCodeVar = SFcnParamSettings.initValueSrcCodeVar
	%assign useAsMaskVar = SFcnParamSettings.useAsMaskVar
	%assign maskOperatorVar = SFcnParamSettings.maskOperatorVar
	%assign useTermValueVar = SFcnParamSettings.useTermValueVar
	%assign termValueVar = SFcnParamSettings.termValueVar
	%assign isNotRealtimeEnabledVar = SFcnParamSettings.isNotRealtimeEnabledVar
	%assign emitCCBeforeWriteVar = SFcnParamSettings.emitCCBeforeWriteVar
	%assign CCBeforeWriteVar = SFcnParamSettings.CCBeforeWriteVar
	%assign emitCCAfterWriteVar = SFcnParamSettings.emitCCAfterWriteVar
	%assign CCAfterWriteVar = SFcnParamSettings.CCAfterWriteVar
	%assign useDMACopyVar = SFcnParamSettings.useDMACopyVar
	%assign enableBlockingModeVar = SFcnParamSettings.enableBlockingModeVar	
	%assign block = block + \ 
	            DAT_MODULE + \
				copyFromVar + \ 
				copyFromAddressSourceVar + \ 
				copyFromAddressVar + \ 
				copyFromSrcCodeVar + \ 
				dataTypeFromVar + \ 
				dataDimensionFromVar + \ 
				useOffsetFromVar + \ 
				offsetFromSrcVar + \ 
				offsetFromVar + \ 
				strideFromVar + \ 
				copyToVar + \ 
				copyToAddressSourceVar + \ 
				copyToAddressVar + \ 
				copyToSrcCodeVar + \ 
				dataTypeToVar + \ 
				useOffsetToVar + \ 
				offsetToSrcVar + \ 
				offsetToVar + \ 
				strideToVar + \ 
				useInitValueVar + \ 
				initValueSrcVar + \ 
				initValueVar + \ 
				initValueSrcCodeVar + \ 
				useAsMaskVar + \ 
				maskOperatorVar + \ 
				useTermValueVar + \ 
				termValueVar + \ 
				isNotRealtimeEnabledVar + \ 
				emitCCBeforeWriteVar + \ 
				CCBeforeWriteVar + \ 
				emitCCAfterWriteVar + \ 
				CCAfterWriteVar + \ 
				useDMACopyVar + \ 
				enableBlockingModeVar + \
                subFamily
%endfunction %% AddParamsToBlock
 

%% --------------------------------------------------------  %%
%%  Create your logic below using defined global data above  %%
%%  The contents above is autogenerated - do not modify it   %% 


%% Function: RenderPreWriteCustomCode ====================================
%function RenderPreWriteCustomCode(block,system) Output
  %if emitCCBeforeWriteVar
      %<CCBeforeWriteVar>
  %endif
%endfunction %% RenderPreWriteCustomCode  


%% Function: RenderPostWriteCustomCode ===================================
%function RenderPostWriteCustomCode(block,system) Output
  %if emitCCAfterWriteVar
      %<CCAfterWriteVar>
  %endif
%endfunction %% RenderPostWriteCustomCode  


%% Function: BlockTypeSetup ==============================================
%function BlockTypeSetup(block, system) void
%endfunction %% BlockTypeSetup

 
%% Function: BlockInstanceSetup ==========================================
%function BlockInstanceSetup(block, system) void
    %<AddParamsToBlock(block)>
    %if ( !EXISTS("::_TLC_ADD_DAT_MODULE_INCLUDES_") && useDMACopyVar && ...
          ((cgHook=="C6000") || (cgHook=="c6000")) )
        %assign ::_TLC_ADD_DAT_MODULE_INCLUDES_ = 1
        %if (subFamily == "645x")
            %%------------------------------------------------------------------
            %% Note that this is a Mathworks module that automatically
            %% manages all four QDMA channels to maximize QDMA throughput.
            %% Original DAT module in the c645x CSL only allows a single QDMA
            %% channel being used and therefore is not suitable for double
            %% buffering. Look into "..\tic6000\tic6000\include\csl_dat3.h" module for QDMA function defns.
            %%------------------------------------------------------------------
            %assign csl_dat3_path = FEVAL("fullfile", MATLAB_ROOT, "toolbox", "rtw", ...
                                          "targets", "tic6000", "tic6000", "include")
            %assign tmp           = FEVAL("tgtLibAddIncPath", csl_dat3_path, CompiledModel.Name) 
            %if (CompiledModel.ConfigSet.ProdEndianess == "BigEndian")
                %assign newSrc = "$(MATLAB_ROOT)\\toolbox\\rtw\\targets\\tic6000\\tic6000\\rtLib\\csl_dat3e.lib"
            %else
                %assign newSrc = "$(MATLAB_ROOT)\\toolbox\\rtw\\targets\\tic6000\\tic6000\\rtLib\\csl_dat3.lib"
            %endif
            %assign tmp    = FEVAL("tgtLibAddSrc", newSrc, CompiledModel.Name)
            %<LibAddToCommonIncludes("<csl_dat3.h>")>
        %elseif ((subFamily == "672x") || (subFamily == "643x"))
            %exit "Memory Copy Block: Quick DMA (QDMA) option for data copy is not supported for this processor"
        %else   
            %<LibAddToCommonIncludes("<csl_dat.h>")>	
        %endif
    %endif
%endfunction %% BlockInstanceSetup


%% Function: GetPortIdx ==================================================              
%function GetPortIdx(block) Output
    %% create structure with fields representing indices of all input/output ports; -1 indicates that
    %% a port (that otherwise might exist) does not exist for the current block option selections 
    %assign FROMINPORT = 1
    %assign FROMADDRESS= 2
    %assign TOOUTPORT  = 1
    %assign TOADDRESS  = 2          
    %createrecord pIdx { srcinp -1; srcadr -1; srcofs -1; dstadr -1; dstofs -1; dstout -1}
    %assign idx = 0
    %assign odx = 0
    %if (copyFromVar==FROMINPORT)
        %assign pIdx.srcinp = idx
        %assign idx = idx + 1
    %endif
    %if (copyFromVar==FROMADDRESS && copyFromAddressSourceVar==2)
        %assign pIdx.srcadr = idx
        %assign idx = idx + 1
    %endif
    %if (useOffsetFromVar && offsetFromSrcVar==2)
        %assign pIdx.srcofs = idx
        %assign idx = idx + 1
    %endif         
    %if (copyToVar==TOADDRESS && copyToAddressSourceVar==2)
        %assign pIdx.dstadr = idx
        %assign idx = idx + 1
    %endif
    %if (useOffsetToVar && offsetToSrcVar==2)
        %assign pIdx.dstofs = idx
        %assign idx = idx + 1
    %endif
     %if (copyToVar==TOOUTPORT)
        %assign pIdx.dstout = odx
        %assign odx = odx + 1
    %endif    
	%return pIdx
%endfunction %% GetPortIdx


%% Function: GetSrcStr ===================================================
%function GetSrcStr(block, DTYPE) Output
    %% construct the string representing the source of the memory copy operation
    %assign FROMINPORT = 1
    %assign FROMADDRESS =2
    %assign FROMSYMBOL = 3    
    %assign pIdx = GetPortIdx(block)        
	%if (copyFromVar==FROMINPORT)
	    %assign ADR = "%<LibBlockInputSignalAddr(pIdx.srcinp,"","",0)>"
	%elseif (copyFromVar==FROMADDRESS)
	    %assign ADR = (copyFromAddressSourceVar==1) ? copyFromAddressVar : "%<LibBlockInputSignal(pIdx.srcadr,"","",0)>"
	%elseif (copyFromVar==FROMSYMBOL)
	    %assign ADR = copyFromSrcCodeVar
	%endif
	%assign OFF = (useOffsetFromVar && offsetFromSrcVar==2) ? "%<LibBlockInputSignal(pIdx.srcofs,"","",0)>" : offsetFromVar
	%% Note: when we do this for c2000, the MAU is 16-bit, and offset needs to be recalculated accordingly
	%assign OFF1 = (copyFromVar==FROMADDRESS) ? "%<OFF> * sizeof(%<DTYPE>)" : OFF
	%assign srcstr = (useOffsetFromVar) && ((offsetFromVar!=0) || (offsetFromSrcVar==2)) ? "%<ADR> + %<OFF1>" : ADR
    %return srcstr
%endfunction %% GetSrcStr  
 

%% Function: GetDstStr ===================================================
%function GetDstStr(block, DTYPE) Output
    %% construct the string representing the destination of the memory copy operation
    %assign TOOUTPORT =1
    %assign TOADDRESS =2
    %assign TOSYMBOL = 3 
    %assign pIdx = GetPortIdx(block)
	%if (copyToVar==TOOUTPORT)
	    %assign ADR = "%<LibBlockOutputSignalAddr(pIdx.dstout,"","",0)>"
	%elseif (copyToVar==TOADDRESS)
	    %assign ADR = (copyToAddressSourceVar==1) ? copyToAddressVar : "%<LibBlockInputSignal(pIdx.dstadr,"","",0)>"
	%elseif (copyToVar==TOSYMBOL)
	    %assign ADR = copyToSrcCodeVar
	%endif
	%assign OFF = (useOffsetToVar && offsetToSrcVar==2) ? "%<LibBlockInputSignal(pIdx.dstofs,"","",0)>" : offsetToVar
    %% Note: when we do this for c2000, the MAU is 16-bit, and offset needs to be recalculated accordingly    	
	%assign OFF1 = (copyToVar==TOADDRESS) ? "%<OFF> * sizeof(%<DTYPE>)" : OFF 
	%assign dststr = (useOffsetToVar) && ((offsetToVar!=0) || (offsetToSrcVar==2)) ? "%<ADR> + %<OFF1>" : ADR
    %return dststr
%endfunction %% GetDstStr 
 

%% Function: Start =======================================================
%function Start(block,system) Output
    %assign INPORT = 1
    %assign OUTPORT =1
    %assign WASDATOPEN = 1    
    %assign INHERITINP = 10
    %assign INHERITSRC = 10
	%assign DTYPES = ["real_T","real32_T","int8_T","uint8_T","int16_T","uint16_T","int32_T","uint32_T","boolean_T"]
	%assign DTYPESRC = (dataTypeFromVar==INHERITINP) ? LibBlockInputSignalDataTypeName(0,"") : DTYPES[dataTypeFromVar-1]
    %assign DTYPEDST = (dataTypeToVar==INHERITSRC) ? DTYPESRC : DTYPES[dataTypeToVar-1]
    %assign OPDST = (strideToVar==1) ? "++" : "+ i*%<strideToVar>"
    %assign OPERAT = ["&", "|","^","<<",">>"]       

    %if (useDMACopyVar || useInitValueVar)
        {              
            %if (useDMACopyVar)
                %% prevent opening of the DAT module if was already open by video blocks
                %if JustCreatedCompiledModelRecord("dm642evm_video_init_code")
                    %assign WASDATOPEN = 0
                %endif
            %endif
            %if (useInitValueVar)            
                %if (dataDimensionFromVar>1)
                    uint16_T i;        
                %endif           
                %assign typecast = (dataTypeToVar<=2) ? "Real" : "Number"    
                %% construct an initialized array of the initial values only when needed 
                %if (initValueSrcVar==1)
                    %assign sizeInitVal = SIZE(initValueVar)     
                    %if (dataDimensionFromVar>1) && ((sizeInitVal[0]>1) || (sizeInitVal[1]>1)) 
                        static const %<DTYPESRC> MemCopyBlock_initial_values [%<dataDimensionFromVar>] = {
                        %foreach k = dataDimensionFromVar
                            %assign initVal = initValueVar[k] 
                            %assign initstr = (k==(dataDimensionFromVar-1)) ? "%<CAST (typecast, initVal)>" : \
                                                                              "%<CAST (typecast, initVal)>,"
                            %<initstr>
                        %endforeach
                        };
                    %endif
                %endif
                %% when needed, initialize the destination given the initial values
                %assign initVal = CAST(typecast, initValueVar[0]) 
                %assign str = (dataDimensionFromVar==1 || ((sizeInitVal[0]==1) && (sizeInitVal[1]==1)) ) ? \
                               initVal : "MemCopyBlock_initial_values[i]"
                %assign str = (initValueSrcVar==1) ? str : "%<initValueSrcCodeVar>"
                %assign UNOP = (useAsMaskVar) ? OPERAT[maskOperatorVar-1] : ""
                {            
                    %<DTYPEDST> *meminddst = (%<DTYPEDST> *) (%<GetDstStr(block,DTYPEDST)>);
        
                    %<RenderPreWriteCustomCode(block,system)>
                    %if (dataDimensionFromVar>1)                         
                        for (i=0; i<%<dataDimensionFromVar>; i++)
                            *(%<DTYPEDST> *) (meminddst%<OPDST>) %<UNOP>= (%<DTYPEDST>) (%<str>);
                    %else
                        *(%<DTYPEDST> *) (meminddst) %<UNOP>= (%<DTYPEDST>) (%<str>);            
                    %endif        
                    %<RenderPostWriteCustomCode(block,system)>
                } 
            %endif
            %if (useDMACopyVar && WASDATOPEN==0)  
                %if (subFamily == "645x")
                    /* Note that this is a Mathworks module that automatically
                     * manages all four QDMA channels to maximize QDMA throughput.
                     * Original DAT module in the c645x CSL only allows a single QDMA
                     * channel being used and therefore is not suitable for double
                     * buffering. Look into "csl_dat3.h" module for QDMA function API.
                     */
                    DAT3_open(DAT_CHAANY, CSL_DAT_PRI_0, 0);
                %elseif (subFamily == "672x")
                    error Quick DMA (QDMA) options for data copy is not supported for C672x series of processors.
                %else     
                    DAT_open(DAT_CHAANY, DAT_PRI_LOW, DAT_OPEN_2D); 
                %endif
            %endif       
        }
    %endif
%endfunction %% Start


%% Function: Outputs =====================================================
%function Outputs(block,system) Output
    %assign INPORT = 1
    %assign OUTPORT =1
    %assign INHERITINP = 10
    %assign INHERITSRC = 10
	%assign DTYPES = ["real_T","real32_T","int8_T","uint8_T","int16_T","uint16_T","int32_T","uint32_T","boolean_T"]
	%assign DTYPESRC = (dataTypeFromVar==INHERITINP) ? LibBlockInputSignalDataTypeName(0,"") : DTYPES[dataTypeFromVar-1]
    %assign DTYPEDST = (dataTypeToVar==INHERITSRC) ? DTYPESRC : DTYPES[dataTypeToVar-1]
    %assign OPSRC = (strideFromVar==1) ? "++" : "+" + "i*%<strideFromVar>"
    %assign OPDST = (strideToVar==1) ? "++" : "+" + "i*%<strideToVar>"

    %if (!isNotRealtimeEnabledVar) %% write at every sample time
        {
            %if (useDMACopyVar==1 && enableBlockingModeVar)
                uint32_T transferID;
            %endif
            %if (!(strideFromVar==1 && strideToVar==1) || (copyFromVar==1 || copyToVar==1)) && (dataDimensionFromVar>1) 
                int_T i;
            %endif
	        %<DTYPESRC> *memindsrc = (%<DTYPESRC> *) (%<GetSrcStr(block,DTYPESRC)>);               
            %<DTYPEDST> *meminddst = (%<DTYPEDST> *) (%<GetDstStr(block,DTYPEDST)>);
              	        
            %<RenderPreWriteCustomCode(block,system)> 
            %if (useDMACopyVar==1)
                %if (enableBlockingModeVar)
            	    transferID = %<DAT_MODULE>_copy(memindsrc, meminddst, %<dataDimensionFromVar>*sizeof(%<DTYPEDST>));                                	
            	    while (%<DAT_MODULE>_busy(transferID));
            	%else
            	    %<DAT_MODULE>_copy(memindsrc, meminddst, %<dataDimensionFromVar>*sizeof(%<DTYPEDST>));            	    
            	%endif
            %elseif (strideFromVar==1 && strideToVar==1 && copyFromVar!=INPORT && copyToVar!=OUTPORT)
                memcpy (meminddst, memindsrc, %<dataDimensionFromVar>*sizeof(%<DTYPEDST>));
            %else
                %if (dataDimensionFromVar>1)                               
                    for (i=0; i<%<dataDimensionFromVar>; i++)
                        *(%<DTYPEDST> *) (meminddst%<OPDST>) = *(%<DTYPESRC> *) (memindsrc%<OPSRC>);
                %else
                    *(%<DTYPEDST> *) (meminddst) = *(%<DTYPESRC> *) (memindsrc);                    
                %endif
            %endif
            %<RenderPostWriteCustomCode(block,system)> 
        }
    %endif
%endfunction %% Outputs
 

%% Function: Terminate ===================================================
%function Terminate(block,system) Output
    %assign INPORT = 1
    %assign OUTPORT =1
    %assign INHERITINP = 10
    %assign INHERITSRC = 10
	%assign DTYPES = ["real_T","real32_T","int8_T","uint8_T","int16_T","uint16_T","int32_T","uint32_T","boolean_T"]
	%assign DTYPESRC = (dataTypeFromVar==INHERITINP) ? LibBlockInputSignalDataTypeName(0,"") : DTYPES[dataTypeFromVar-1]
    %assign DTYPEDST = (dataTypeToVar==INHERITSRC) ? DTYPESRC : DTYPES[dataTypeToVar-1]
    %assign OPDST = (strideToVar==1) ? "++" : "+" + "i*%<strideToVar>"    
    %if (useTermValueVar)
        {
            %assign typecast = (dataTypeToVar<=2) ? "Real" : "Number"  
            %assign sizeTermVal = SIZE(termValueVar)  
            %if (dataDimensionFromVar>1)            
                int_T i;
            %endif
            %% construct an initialized array of the termination values only when needed           
            %if (dataDimensionFromVar>1) && ((sizeTermVal[0]>1) || (sizeTermVal[1]>1))                    
                static const %<DTYPESRC> MemCopyBlock_terminal_values [%<dataDimensionFromVar>] = {
                %foreach k = dataDimensionFromVar
                    %assign termVal = termValueVar[k] 
                    %assign termstr = (k==(dataDimensionFromVar-1)) ? "%<CAST (typecast, termVal)>" : \
                                                                      "%<CAST (typecast, termVal)>,"
                    %<termstr>
                %endforeach
                };
            %endif
            %% when needed, set the destination given the terminal values 

            %assign termVal = CAST(typecast, termValueVar[0]) 
            %assign str = (dataDimensionFromVar==1 || ((sizeTermVal[0]==1) && (sizeTermVal[1]==1)) ) ? \
                           termVal : "MemCopyBlock_terminal_values[i]"
            {
                %<DTYPEDST> *meminddst = (%<DTYPEDST> *) (%<GetDstStr(block,DTYPEDST)>);
    
                %<RenderPreWriteCustomCode(block,system)> 
                %if (dataDimensionFromVar>1)           
                    for (i=0; i<%<dataDimensionFromVar>; i++)
                        *(%<DTYPEDST> *) (meminddst%<OPDST>) = (%<DTYPEDST>) (%<str>);
                %else
                    *(%<DTYPEDST> *) (meminddst) = (%<DTYPEDST>) (%<str>);           
                %endif        
                %<RenderPostWriteCustomCode(block,system)>
            }
        }
    %endif
%endfunction %% Terminate
 
