
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Build a Digital Voltmeter</title><meta name="generator" content="MATLAB 9.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-07-25"><meta name="DC.source" content="BuildADigitalVoltmeterExample.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><style>
.open_example { 
    padding:0px 0px 1px 0px;
    margin:20px;
    font-size:0.9em;
    border:1px solid #aeaeae;
    display:block;
    float:right;
    border-radius:5px; -moz-border-radius:5px; -webkit-border-radius:5px;
    background: #ffffff; /* Old browsers */
    background: -moz-linear-gradient(top, #FFFFFF 0%, #E6E6E6 100%); /* FF3.6+ */	
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#FFFFFF), color-stop(100%,#E6E6E6)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top, #FFFFFF 0%,#E6E6E6 100%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* IE10+ */
    background: linear-gradient(top,  #ffffff 0%,#e6e6e6 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#FFFFFF', endColorstr='#E6E6E6',GradientType=0 ); /* IE6-9 */
}

.open_example:hover {
    background: #f3f3f3; /* Old browsers */
    background: -moz-linear-gradient(top, #f3f3f3 0%, #d7d7d7 100%); /* FF3.6+ */    
    background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#f3f3f3), color-stop(100%,#d7d7d7)); /* Chrome,Safari4+ */
    background: -webkit-linear-gradient(top, #f3f3f3 0%,#d7d7d7 100%); /* Chrome10+,Safari5.1+ */
    background: -o-linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* Opera 11.10+ */
    background: -ms-linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* IE10+ */
    background: linear-gradient(top,  #f3f3f3 0%,#d7d7d7 100%); /* W3C */
    filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#f3f3f3', endColorstr='#d7d7d7',GradientType=0 ); /* IE6-9 */
} 

.open_example a { 
    padding:6px 10px; 
    line-height:130%;
    text-decoration:none;
    float:left;
}
      </style><div class="open_example"><a href="matlab:openExample('raspberrypiio/BuildADigitalVoltmeterExample')">Open this Example</a></div><div class="content"><h1>Build a Digital Voltmeter</h1><!--introduction--><p>This example shows you how to build a digital voltmeter using MATLAB&reg; Support Package for Raspberry Pi&reg; Hardware.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Introduction</a></li><li><a href="#2">Prerequisites</a></li><li><a href="#3">Required Hardware</a></li><li><a href="#4">Connect MCP3008</a></li><li><a href="#5">Connect the Display</a></li><li><a href="#6">View available SPI channels</a></li><li><a href="#7">Scan I2C bus</a></li><li><a href="#8">Read voltage</a></li><li><a href="#9">Test the Segmented Display</a></li><li><a href="#10">Display Voltage Measurements</a></li><li><a href="#11">Summary</a></li></ul></div><h2 id="1">Introduction</h2><p>In this example you combine the MCP3008 ADC with a 4-digit 7-segment display module to build a digital voltmeter. You connect the MCP3008 ADC to the Raspberry Pi hardware using SPI peripheral. You connect the 4-digit 7-segment display to the Raspberry Pi hardware using the I2C peripheral. A potentiometer connected to one of the analog inputs of the MCP3008 ADC provides a variable input voltage. You measure this voltage and display it on the segmented display.</p><p>You can replace the potentiometer with an analog temperature sensor or a photo-resistor to build a digital thermometer or a digital light sensor.</p><h2 id="2">Prerequisites</h2><p>It is helpful to complete the following examples</p><div><ul><li><a href="docid:raspberrypiio_ref.example-raspi_analog_input_using_spi">Analog Input Using SPI</a> example.</li></ul></div><div><ul><li><a href="docid:raspberrypiio_ref.example-raspi_segmented_display_using_i2c">Controlling a 4-digit 7-Segment Display Using I2C</a> example.</li></ul></div><h2 id="3">Required Hardware</h2><p>To run this example you need the following hardware:</p><div><ul><li>Raspberry Pi hardware</li><li>A power supply with at least 1A output</li><li>Breadboard and jumper cables</li><li>MCP3008 ADC</li><li>10 kOhm potentiometer</li><li>A 4-digit, 7-segment display with I2C interface from SparkFun</li></ul></div><h2 id="4">Connect MCP3008</h2><p>Connect MCP3008 to the Raspberry Pi hardware as seen in the following circuit diagram. To simulate a variable voltage applied to CH0, use a 10 kOhm potentiometer connected to CH0.</p><p><img vspace="5" hspace="5" src="../mcp3008_circuit.png" alt=""> </p><p>The potentiometer (POT), in this example, is a three-terminal device with terminals 1 and 3 comprising the end points of a resistor embedded in the POT. The second terminal is connected to a variable wiper. As the wiper moves, the resistance values across terminals 1 and 2 and terminals 2 and 3 change. In this circuit, POT acts as a variable voltage divider. As you move the knob of the potentiometer, the voltage seen at terminal 2 changes between 3.3 Volts and 0 volts.</p><h2 id="5">Connect the Display</h2><p>To connect the display to Raspberry Pi hardware, you need to do some light soldering. Since you use the I2C interface of the display in this example, solder jumper wires to the SDA, SCL, GND and VCC pins of the display. You can also choose to solder some straight male headers to be able to mount the display on a breadboard for prototyping. Before going any further, follow manufacturer's hardware assembly guide.</p><p>Connect the display to the Raspberry Pi hardware following the circuit diagram below.</p><p><img vspace="5" hspace="5" src="../segment_display_circuit.png" alt=""> </p><h2 id="6">View available SPI channels</h2><p>Create a raspi object and inspect the AvailableSPIChannels property of the raspi object.</p><pre class="language-matlab">clear <span class="string">rpi</span>
rpi = raspi();
rpi.AvailableSPIChannels
</pre><p>If the SPI peripheral is not enabled, you will see an empty cell array. To enable the SPI peripheral use the raspi-config utility that comes with the Raspbian Linux image. AvailableSPIChannels property of the rpi object should yield 'CE0' and 'CE1' SPI channels listed as available.</p><h2 id="7">Scan I2C bus</h2><p>Once the display is connected to the Raspberry Pi hardware, test the presence of the display on the I2C bus.</p><pre class="language-matlab"><span class="keyword">for</span> i = 1:length(rpi.AvailableI2CBuses)
    scanI2CBus(rpi, rpi.AvailableI2CBuses{i})
<span class="keyword">end</span>
</pre><p>The scanI2CBus() method scans the given I2C bus and returns a cell array of device addresses on the bus. If you connected the display to Raspberry Pi hardware correctly, the snippet of MATLAB code above should return a device address of '0x71' for one of the I2C buses available on the Raspberry Pi hardware. '0x71' is the factory default address of the display.</p><h2 id="8">Read voltage</h2><p>Create an MCP3008 object to read the voltage value at Channel 0 of the ADC.</p><pre class="language-matlab">clear <span class="string">mcp3008</span>
mcp3008 = raspi.internal.mcp3008(rpi, <span class="string">'CE0'</span>);
<span class="keyword">for</span> i = 1:20
    voltage = readVoltage(mcp3008, 0);
    fprintf(<span class="string">'Voltage = %0.2f\n'</span>, voltage);
    pause(0.2);
<span class="keyword">end</span>
</pre><p>Try playing with the POT knob while executing the loop above. You should observe that the voltage value printed on the MATLAB prompt change.</p><h2 id="9">Test the Segmented Display</h2><p>Create a segmented display object connected to the appropriate I2C bus on the Raspberry Pi hardware.</p><pre class="language-matlab">clear <span class="string">sd</span>
sd = raspi.internal.segmentdisplay(rpi, &lt;I2C bus&gt;, &lt;I2C address&gt;)
clr(sd);  <span class="comment">% Clear screen</span>
print(sd, <span class="string">'112'</span>);
print(sd, <span class="string">'dead'</span>);
print(sd, <span class="string">'beef'</span>);
</pre><p>Substitute the correct I2C bus and I2C address for your segmented display.</p><h2 id="10">Display Voltage Measurements</h2><p>Read the voltage at Channel 0 of the MCP3008 ADC and display it on the segmented display every 0.1 seconds.</p><pre class="language-matlab">delay = 0.1;
adcChannel = 0;
clr(sd);
<span class="keyword">for</span> i = 1:N
    voltage = readVoltage(mcp3008,adcChannel);
    print(sd,sprintf(<span class="string">'%0.0f'</span>, voltage*100));
    pause(delay);
<span class="keyword">end</span>
</pre><h2 id="11">Summary</h2><p>This example showed how to use a MCP3008 ADC and a segmented display connected to Raspberry Pi hardware to build a digital voltmeter application.</p><p class="footer">Copyright 2013-2014 The MathWorks, Inc.<br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018b</a><br><br>
		  MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.
      </p></div><!--
##### SOURCE BEGIN #####
%% Build a Digital Voltmeter
%
% This example shows you how to build a digital voltmeter using MATLAB(R)
% Support Package for Raspberry Pi(R) Hardware.
 
% Copyright 2013-2014 The MathWorks, Inc.
 

%% Introduction
%
% In this example you combine the MCP3008 ADC with a 4-digit 7-segment
% display module to build a digital voltmeter. You connect the MCP3008 ADC
% to the Raspberry Pi hardware using SPI peripheral. You connect the
% 4-digit 7-segment display to the Raspberry Pi hardware using the I2C
% peripheral. A potentiometer connected to one of the analog inputs of the
% MCP3008 ADC provides a variable input voltage. You measure this voltage
% and display it on the segmented display.
% 
% You can replace the potentiometer with an analog temperature sensor or a
% photo-resistor to build a digital thermometer or a digital light sensor.


%% Prerequisites
%
% It is helpful to complete the following examples
% 
% * <docid:raspberrypiio_ref.example-raspi_analog_input_using_spi Analog Input Using SPI> example.
% 
% * <docid:raspberrypiio_ref.example-raspi_segmented_display_using_i2c Controlling a 4-digit 7-Segment Display Using I2C> example.


%% Required Hardware
% 
% To run this example you need the following hardware:
% 
% * Raspberry Pi hardware
% * A power supply with at least 1A output
% * Breadboard and jumper cables
% * MCP3008 ADC
% * 10 kOhm potentiometer
% * A 4-digit, 7-segment display with I2C interface from SparkFun


%% Connect MCP3008 
% 
% Connect MCP3008 to the Raspberry Pi hardware as seen in the following
% circuit diagram. To simulate a variable voltage applied to CH0,
% use a 10 kOhm potentiometer connected to CH0.
%
% <<../mcp3008_circuit.png>>
%
% The potentiometer (POT), in this example, is a three-terminal device with
% terminals 1 and 3 comprising the end points of a resistor embedded in the
% POT. The second terminal is connected to a variable wiper. As the wiper
% moves, the resistance values across terminals 1 and 2 and terminals 2 and
% 3 change. In this circuit, POT acts as a variable voltage divider. As you
% move the knob of the potentiometer, the voltage seen at terminal 2
% changes between 3.3 Volts and 0 volts.


%% Connect the Display 
% 
% To connect the display to Raspberry Pi hardware, you need to do some
% light soldering. Since you use the I2C interface of the display in this
% example, solder jumper wires to the SDA, SCL, GND and VCC pins of the
% display. You can also choose to solder some straight male headers to be
% able to mount the display on a breadboard for prototyping. Before going
% any further, follow manufacturer's hardware assembly guide.
%
% Connect the display to the Raspberry Pi hardware following the circuit
% diagram below.
%
% <<../segment_display_circuit.png>>
%


%% View available SPI channels
%
% Create a raspi object and inspect the
% AvailableSPIChannels property of the raspi object.
%  
%   clear rpi
%   rpi = raspi();
%   rpi.AvailableSPIChannels
%
% If the SPI peripheral is not enabled, you will see an empty cell array.
% To enable the SPI peripheral use the raspi-config utility that comes with
% the Raspbian Linux image. AvailableSPIChannels property of the rpi object
% should yield 'CE0' and 'CE1' SPI channels listed as available.


%% Scan I2C bus
% 
% Once the display is connected to the Raspberry Pi hardware, test the
% presence of the display on the I2C bus.
%
%   for i = 1:length(rpi.AvailableI2CBuses)
%       scanI2CBus(rpi, rpi.AvailableI2CBuses{i})
%   end
%
% The scanI2CBus() method scans the given I2C bus and returns a cell array
% of device addresses on the bus. If you connected the display to Raspberry
% Pi hardware correctly, the snippet of MATLAB code above should return a
% device address of '0x71' for one of the I2C buses available on the
% Raspberry Pi hardware. '0x71' is the factory default address of the
% display.


%% Read voltage
% 
% Create an MCP3008 object to read the voltage value at Channel 0 of the
% ADC.
%  
%   clear mcp3008
%   mcp3008 = raspi.internal.mcp3008(rpi, 'CE0');
%   for i = 1:20
%       voltage = readVoltage(mcp3008, 0);
%       fprintf('Voltage = %0.2f\n', voltage);
%       pause(0.2);
%   end
%
% Try playing with the POT knob while executing the loop above. You should
% observe that the voltage value printed on the MATLAB prompt change.


%% Test the Segmented Display
%
% Create a segmented display object connected to the appropriate I2C bus on
% the Raspberry Pi hardware.
%
%   clear sd
%   sd = raspi.internal.segmentdisplay(rpi, <I2C bus>, <I2C address>)
%   clr(sd);  % Clear screen
%   print(sd, '112');
%   print(sd, 'dead');
%   print(sd, 'beef');
%
% Substitute the correct I2C bus and I2C address for your segmented display.

%% Display Voltage Measurements
% 
% Read the voltage at Channel 0 of the MCP3008 ADC and display it on the
% segmented display every 0.1 seconds.
%
%   delay = 0.1;
%   adcChannel = 0;
%   clr(sd);
%   for i = 1:N
%       voltage = readVoltage(mcp3008,adcChannel);
%       print(sd,sprintf('%0.0f', voltage*100));
%       pause(delay);
%   end


%% Summary
%
% This example showed how to use a MCP3008 ADC and a segmented display
% connected to Raspberry Pi hardware to build a digital voltmeter
% application.


##### SOURCE END #####
--></body></html>